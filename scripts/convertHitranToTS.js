/**
 * Convert HITRAN line-by-line CSV data into binned absorption cross-sections
 *
 * Input: HITRAN CSV files with columns: nu, sw, elower, gamma_air, n_air, etc.
 * Output: TypeScript file with binned absorption coefficients
 *
 * Key conversions:
 * - nu: wavenumber (cm⁻¹) → wavelength (μm): λ = 10000 / ν
 * - sw: line intensity at 296K (cm⁻¹/(molecule·cm⁻²)) = absorption cross-section
 * - Binning: sum all sw values falling within each wavelength bin
 * 
 * Usage: node scripts/convertHitranToTS.js
 */

import fs from 'fs';
import path from 'path';
import Papa from 'papaparse';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// === CONFIGURATION ===
const NUM_BINS = 512;
const WAVELENGTH_MIN = 1.0; // μm
const WAVELENGTH_MAX = 70.0; // μm

// Gases to process (must match directory names in public/hitran-line/)
const GASES = ['ch4', 'co', 'co2', 'h2o', 'n2', 'n2o', 'o2', 'o3', 'so2', 'hcl', 'hfl'];

// === HELPER FUNCTIONS ===

/**
 * Generate log-spaced bin edges
 * Returns array of length NUM_BINS+1 (bin edges)
 */
function generateLogBins(min, max, numBins) {
	const logMin = Math.log10(min);
	const logMax = Math.log10(max);
	const step = (logMax - logMin) / numBins;

	const edges = [];
	for (let i = 0; i <= numBins; i++) {
		edges.push(Math.pow(10, logMin + i * step));
	}
	return edges;
}

/**
 * Get bin centers from edges
 */
function getBinCenters(edges) {
	const centers = [];
	for (let i = 0; i < edges.length - 1; i++) {
		// Geometric mean for log-spaced bins
		centers.push(Math.sqrt(edges[i] * edges[i + 1]));
	}
	return centers;
}

/**
 * Convert wavenumber (cm⁻¹) to wavelength (μm)
 */
function wavenumberToWavelength(nu_cm) {
	return 10000.0 / nu_cm; // μm
}

/**
 * Process a single HITRAN CSV file
 * Returns { wavelengths: number[], crossSections: number[] }
 */
function processHitranFile(csvPath) {
	console.log(`Processing ${csvPath}...`);

	const csvData = fs.readFileSync(csvPath, 'utf8');
	const parsed = Papa.parse(csvData, { header: true, skipEmptyLines: true });

	// Generate wavelength bins
	const binEdges = generateLogBins(WAVELENGTH_MIN, WAVELENGTH_MAX, NUM_BINS);
	const binCenters = getBinCenters(binEdges);

	let linesProcessed = 0;
	let linesInRange = 0;

	// Collect line intensities per bin (for median calculation)
	const binLines = Array.from({ length: NUM_BINS }, () => []);

	// Process each spectral line
	for (const row of parsed.data) {
		linesProcessed++;

		const nu = parseFloat(row.nu); // wavenumber (cm⁻¹)
		const sw = parseFloat(row.sw); // line intensity (cm⁻¹/(molecule·cm⁻²))

		if (isNaN(nu) || isNaN(sw)) continue;

		// Convert wavenumber to wavelength
		const wavelength = wavenumberToWavelength(nu);

		// Check if wavelength is in range
		if (wavelength < WAVELENGTH_MIN || wavelength > WAVELENGTH_MAX) continue;

		linesInRange++;

		// Find which bin this line falls into
		for (let i = 0; i < NUM_BINS; i++) {
			if (wavelength >= binEdges[i] && wavelength < binEdges[i + 1]) {
				binLines[i].push(sw);
				break;
			}
		}
	}

	console.log(`  Processed ${linesProcessed} lines, ${linesInRange} in wavelength range`);

	// Calculate mean of line intensities
	const getMean = (arr) => {
		if (arr.length === 0) return 0;
		return arr.reduce((sum, val) => sum + val, 0) / arr.length;
	};

	// Use mean line intensity for each bin
	const crossSections = binLines.map((lines) => {
		return getMean(lines);
	});

	return {
		wavelengths: binCenters,
		crossSections: crossSections
	};
}

/**
 * Find the CSV file for a given gas
 */
function findGasCSV(gas) {
	const gasDir = path.join(__dirname, '..', 'public', 'hitran-line', gas);
	const files = fs.readdirSync(gasDir);
	const csvFile = files.find(f => f.endsWith('.csv'));

	if (!csvFile) {
		throw new Error(`No CSV file found for gas: ${gas}`);
	}

	return path.join(gasDir, csvFile);
}

/**
 * Main processing function
 */
function main() {
	console.log('Converting HITRAN line-by-line data to binned cross-sections');
	console.log(`Bins: ${NUM_BINS} (log-spaced from ${WAVELENGTH_MIN} to ${WAVELENGTH_MAX} μm)\n`);

	const results = {};

	// Process each gas
	for (const gas of GASES) {
		try {
			const csvPath = findGasCSV(gas);
			const data = processHitranFile(csvPath);
			results[gas] = data;
		} catch (error) {
			console.error(`Error processing ${gas}: ${error.message}`);
		}
	}

	// Generate TypeScript output
	let tsContent = '// HITRAN line-by-line data converted to binned absorption cross-sections\n';
	tsContent += '// Generated by scripts/convertHitranToTS.js\n';
	tsContent += '//\n';
	tsContent += '// Data format:\n';
	tsContent += `//   Bins: ${NUM_BINS} log-spaced from ${WAVELENGTH_MIN} to ${WAVELENGTH_MAX} μm\n`;
	tsContent += '//   Cross-sections: cm⁻¹/(molecule·cm⁻²) = cm/molecule (summed line intensities per bin)\n';
	tsContent += '//   Reference temperature: 296 K\n';
	tsContent += '//\n';
	tsContent += '// To calculate optical depth for arbitrary column density N (molecules/cm²):\n';
	tsContent += '//   τ = σ × N (dimensionless, since cm/molecule × molecules/cm² = cm⁻¹ × cm = dimensionless)\n';
	tsContent += '//   T = exp(-τ)\n';
	tsContent += '//\n';
	tsContent += '// Temperature scaling (if needed):\n';
	tsContent += '//   S(T) = S(296) × (Q(296)/Q(T)) × exp(-c₂E"/T) × (1 - exp(-c₂ν/T)) / (1 - exp(-c₂ν/296))\n';
	tsContent += '//   where c₂ = 1.4388 cm·K, E" = lower state energy, Q = partition function\n';
	tsContent += '\n';

	tsContent += 'export type HitranCrossSectionSpectrum = {\n';
	tsContent += '\twavelengths: number[];  // μm (bin centers)\n';
	tsContent += '\tcrossSections: number[]; // cm²/molecule\n';
	tsContent += '};\n\n';

	// Write data for each gas
	for (const [gas, data] of Object.entries(results)) {
		const varName = `${gas}CrossSection`;

		tsContent += `export const ${varName}: HitranCrossSectionSpectrum = {\n`;
		tsContent += '\twavelengths: [\n\t\t';
		tsContent += data.wavelengths.map(w => w.toExponential(6)).join(', ');
		tsContent += '\n\t],\n';
		tsContent += '\tcrossSections: [\n\t\t';
		tsContent += data.crossSections.map(cs => cs.toExponential(6)).join(', ');
		tsContent += '\n\t]\n';
		tsContent += '};\n\n';
	}

	// Write aggregated data structure
	tsContent += 'export const allHitranCrossSections: Record<string, HitranCrossSectionSpectrum> = {\n';
	for (const gas of GASES) {
		tsContent += `\t${gas}: ${gas}CrossSection,\n`;
	}
	tsContent += '};\n';

	// Write output file
	const outputPath = path.join(__dirname, '..', 'src', 'experiment', 'hitranCrossSections.ts');
	fs.writeFileSync(outputPath, tsContent, 'utf8');

	console.log(`\nOutput written to: ${outputPath}`);
	console.log('\nSummary:');
	for (const [gas, data] of Object.entries(results)) {
		const totalCrossSection = data.crossSections.reduce((a, b) => a + b, 0);
		const maxCrossSection = Math.max(...data.crossSections);
		console.log(`  ${gas}: total=${totalCrossSection.toExponential(3)}, max=${maxCrossSection.toExponential(3)} cm²/molecule`);
	}
}

main();
